/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.intel.dai.volt;

import com.intel.logging.Logger;
import com.intel.xdg.XdgConfigFile;
import org.voltdb.VoltType;
import org.voltdb.client.*;

import java.io.*;
import java.net.ConnectException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeoutException;
import java.util.regex.Pattern;

/**
 * Class with static function to either setup voltdb or to wait if voltdb is not ready but being setup. Error states
 * in the VoltDB DBStatus table are taken into account.
 */
public class VoltDBSetup {
    // These can be tweaked for different timeout and loop behaviors.
    static final long CONNECT_TIMEOUT_SECONDS = 60L; // Too long??? too short???
    static final long LOOP_DELAY_MS = 300L; // Milliseconds to be clear.

    /**
     * Will either setup VoltDB or will wait until VoltDB is READY.
     *
     * @param voltServers Comma separated list of VoltDB servers. Cannot be null or empty.
     * @param timeoutSeconds Timeout for wait operation (not setup) in seconds.
     * @param logger Callers logger to be used inside this class.
     *
     * @return True if VoltDB is READY, false if the wait timed out, the setup failed, or the initial state was bad!
     */
    public static boolean setupVoltDBOrWait(String voltServers, long timeoutSeconds, Logger logger) {
        XdgConfigFile xdg = new XdgConfigFile("ucs");
        String manifest = xdg.FindFile("SystemManifest.json");
        String config = xdg.FindFile("MachineConfig.json");
        String metadata = xdg.FindFile("RasEventMetaData.json");
        String sql = xdg.FindFile("Combined_VoltDB.sql");
        String procedures = new File(VoltDBSetup.class.getProtectionDomain().getCodeSource().getLocation().getPath()).
                getParentFile().toString() + "/procedures.jar";
        try {
            new VoltDBSetup(voltServers, timeoutSeconds * 3L / 4L, procedures, sql, manifest, config, metadata, logger).
                    setupOrWaitForVoltDB(timeoutSeconds);
            return true;
        } catch (IOException | TimeoutException | DaiBadStateException e) {
            logger.exception(e);
            return false;
        }
    }

    VoltDBSetup(String servers, long connectTimeoutSeconds, String jar, String sqlFile, String manifest, String machine, String rasData,
                       Logger logger)
            throws IOException { // should only throw this if there is a program error!!!!
        log_ = logger;
        connectTimeoutSeconds_ = connectTimeoutSeconds;
        voltdbServers_ = servers;
        localJarFile_ = jar;
        systemManifestFile_ = manifest;
        machineConfigFile_ = machine;
        rasEventMetaDataFile_ = rasData;
        sql_ = Files.readString(new File(sqlFile).toPath(), StandardCharsets.UTF_8);
    }

    void setupOrWaitForVoltDB(long timeoutSeconds) throws DaiBadStateException, TimeoutException {
        if(!checkDNSServerNames(voltdbServers_))
            return;
        DaiVoltState state = checkVoltState();
        if(state == DaiVoltState.EMPTY) {
            log_.info("Initializing VoltDB...");
            setupVoltDB(state);
        }
        else if(state == DaiVoltState.SCHEMA_ERROR || state == DaiVoltState.POPULATED_ERROR) {
            closeClient();
            throw new DaiBadStateException("The VoltDB server(s) specified are in a bad state: '" +
                    state.toString() + "'");
        } else {
            long start = System.currentTimeMillis() / 1_000;
            long current = start;
            log_.info("Waiting for VoltDB to be ready...");
            while((current - start) <= timeoutSeconds) {
                state = checkVoltState();
                if(state == DaiVoltState.SCHEMA_ERROR || state == DaiVoltState.POPULATED_ERROR) {
                    closeClient();
                    throw new DaiBadStateException("The VoltDB server(s) specified are in a bad state: '" +
                            state.toString() + "'");
                } else if(state == DaiVoltState.READY)
                    break;
                safeLoopSleep(); // Wait LOOP_DELAY_MS and try again.
                current = System.currentTimeMillis() / 1_000;
            }
            if((current - start) > timeoutSeconds) {
                closeClient();
                throw new TimeoutException("Timed out waiting for VoltDB to be ready!");
            }
        }
        log_.info("VoltDB is ready.");
    }

    void setupVoltDB(DaiVoltState previousState) throws DaiBadStateException {
        DaiVoltState state = previousState;
        if(badStates_.contains(state)) {
            closeClient();
            throw new DaiBadStateException(
                    "The VoltDB server(s) specified are in a bad state and cannot be setup for DAI currently: " +
                            "State = '" + state.name() + "'");
        }
        if(state == DaiVoltState.EMPTY)
            state = createSchema();
        if(state == DaiVoltState.SCHEMA_LOADED)
            state = populateData();
        if(badStates_.contains(state)) {
            closeClient();
            throw new DaiBadStateException(
                    "The VoltDB server(s) specified are in a bad state after attempting setup and cannot be used for " +
                            "DAI currently: State = '" + state.name() + "'");
        }
        closeClient();
    }

    DaiVoltState checkVoltState() {
        try {
            if(client_ == null)
                connect();
        } catch (TimeoutException | IOException e) {
            log_.exception(e);
            client_ = null;
            return DaiVoltState.CANNOT_CONNECT;
        }
        DaiVoltState state = DaiVoltState.EMPTY;
        try {
            ClientResponse response = executeAdHoc(selectStatus);
            if(response.getStatus() != ClientResponse.SUCCESS) {
                // DB is up, no exception, but no SUCCESS either (extreme edge case)
                throw new RuntimeException("Something unexpected happen getting a response from VoltDB!");
            } else if(response.getResults()[0].getRowCount() == 1) {
                response.getResults()[0].advanceRow();
                String result = (String)(response.getResults()[0].get("Status", VoltType.STRING));
                return conversionMap_.get(result);
            } else
                return DaiVoltState.SCHEMA_LOADING; // TABLE is present but not the initial state (no rows).
        } catch (IOException | ProcCallException e) {
            /* Intentionally not logging an exception here! */
        }
        return state;
    }

    void closeClient() {
        if(client_ != null) {
            try {
                client_.drain();
            } catch (InterruptedException | NoConnectionsException e) {
                log_.exception(e);
            }
            try {
                client_.close();
            } catch (InterruptedException e) {
                log_.exception(e);
            }
            client_ = null;
        }
    }

    void checkResponse(ClientResponse response, String errorMsg) throws DaiBadStateException {
        if(response.getStatus() != ClientResponse.SUCCESS) {
            log_.error("VoltDB Client Procedure Error: %s", response.getStatusString());
            throw new DaiBadStateException(errorMsg);
        }
    }

    void checkResponseThrowIOException(ClientResponse response, String errorMsg) throws IOException {
        if(response.getStatus() != ClientResponse.SUCCESS) {
            log_.error("VoltDB Client Procedure Error: %s", response.getStatusString());
            throw new IOException(errorMsg);
        }
    }

    DaiVoltState createSchema() throws DaiBadStateException {
        DaiVoltState state;
        try {
            loadSchema();
            state = checkVoltState();
        } catch (IOException | ProcCallException e) {
            try {
                setSchemaFailedState(exceptToString(e));
            } catch (IOException | ProcCallException e2) {
                log_.exception(e2, "Failed to store the 'SCHEMA_ERROR' state!");
                throw new DaiBadStateException(
                        "After a state of 'EMPTY', the VoltDB server(s) specified failed to execute the SQL for " +
                                "loading the DAI schema! The current state will be hung at 'SCHEMA_LOADING'");
            }
            throw new DaiBadStateException(
                    "After a state of 'EMPTY', the VoltDB server(s) specified failed to execute the SQL for " +
                            "loading the DAI schema! The current state will be 'SCHEMA_ERROR'");
        }
        return state;
    }

    DaiVoltState populateData() throws DaiBadStateException {
        DaiVoltState state;
        DataLoader loader = new DataLoader(log_);
        String errMsg1 = "Cannot update the DAI volt to 'POPULATE_STARTED' so we cannot " +
                "continue with population of the data into the DAI schema!";
        String errMsg2 = "Failed to populate the data into the Volt DB, please see the log " +
                "file for details. Failed to update the volt status to 'POPULATED_ERROR', so the state " +
                "is hung in 'POPULATED_STARTED'";
        String errMsg3 = "Although the populate data succeeded, updating the DAI volt " +
                "state to 'READY' failed!";
        try {
            checkResponse(executeAdHoc(populateStarting), errMsg1);
        } catch (IOException | ProcCallException e) {
            log_.exception(e);
            throw new DaiBadStateException(errMsg1);
        }
        int result = loader.doPopulate(client_, systemManifestFile_, machineConfigFile_, rasEventMetaDataFile_);
        if(result != 0) {
            try {
                checkResponse(setPopulateFailed(), errMsg2);
            } catch (IOException | ProcCallException e) {
                log_.exception(e);
                throw new DaiBadStateException(errMsg2);
            }
            throw new DaiBadStateException("Failed to populate the data into the Volt DB, please see the log " +
                    "file for details!");
        } else {
            try {
                checkResponse(executeAdHoc(populateFinished), errMsg3);
            } catch (IOException | ProcCallException e) {
                log_.exception(e);
                throw new DaiBadStateException(errMsg3);
            }
        }
        state = checkVoltState();
        return state;
    }

    protected Client createClient(ClientConfig config) { // Hook for testing...
        return ClientFactory.createClient(config);
    }

    void connect() throws IOException, TimeoutException {
        if(client_ != null)
            return;
        long start = System.currentTimeMillis() / 1_000L; // Time in seconds since epoch.
        long end = start;
        ClientConfig config = new ClientConfig();
        config.setInitialConnectionRetryInterval(1_000L);
        config.setMaxConnectionRetryInterval(2_500L);
        config.setConnectionResponseTimeout(1_000L);
        config.setReconnectOnConnectionLoss(true);
        while((end - start) <= connectTimeoutSeconds_) {
            try {
                client_ = createClient(config);
                client_.createConnection(voltdbServers_);
                end = System.currentTimeMillis() / 1_000L; // Time in seconds since epoch.
                break;
            } catch (ConnectException e) {
                log_.exception(e);
                safeLoopSleep(); // Wait LOOP_DELAY_MS and try again.
            } catch (IOException e) {
                log_.exception(e);
                try {
                    client_.close();
                } catch(InterruptedException e2) {
                    log_.exception(e);
                } finally {
                    client_ = null;
                }
                throw e;
            }
            end = System.currentTimeMillis() / 1_000L; // Time in seconds since epoch.
        }
        long left = connectTimeoutSeconds_ - (end - start);
        if(left < 0L) {
            client_ = null;
            throw new TimeoutException("Connection to VoltDB servers timed out!");
        }
    }

    void loadSchema() throws IOException, ProcCallException {
        ClientResponse response;
        try {
            response = executeUpdateClasses(localJarFile_);
            if(response.getStatus() != ClientResponse.SUCCESS) {
                log_.error("CLIENT ERROR: " + response.getStatusString());
                throw new RuntimeException("CLIENT ERROR: " + response.getStatusString());
            }
        } catch(Exception e) {
            log_.exception(e, "Failed to install the JAR file '%s'!", localJarFile_);
        }
        checkResponseThrowIOException(executeAdHoc(dbStatusTableAndProcedures), "Failed to create DBStatus Table!");
        checkResponseThrowIOException(executeAdHoc(schemaLoading), "Failed to set initial state 'SCHEMA_LOADING'!");
        checkResponseThrowIOException(executeAdHoc(sql_), "Failed to load the DAI tables and procedures!");
        checkResponseThrowIOException(executeAdHoc(tier2ConfigFalse), "Failed to set Tier2_Config value to false!");
        checkResponseThrowIOException(executeAdHoc(schemaLoaded), "Failed to set final state 'SCHEMA_LOADED'!");
    }

    ClientResponse setPopulateFailed() throws IOException, ProcCallException {
        return client_.callProcedure("@AdHoc", populateError, "Failed to populate data into the DAI schema!");
    }

    ClientResponse executeAdHoc(String sql) throws IOException, ProcCallException {
        return client_.callProcedure("@AdHoc", sql);
    }

    ClientResponse executeUpdateClasses(String localFilename) throws IOException, ProcCallException {
        return client_.updateClasses(new File(localFilename),"");
    }

    void setSchemaFailedState(String description) throws IOException, ProcCallException {
        client_.callProcedure("SetDbSchemaFailed", description);
    }

    void safeLoopSleep() {
        try {
            Thread.sleep(LOOP_DELAY_MS);
        } catch(InterruptedException e) { /* Ignore interruption here */ }
    }

    boolean checkDNSServerNames(String servers) {
        boolean result = true;
        String[] serverArray = servers.split(",");
        Pattern pattern = Pattern.compile("[0-9]+\\.[0-9]\\.[0-9]\\.[0-9]");
        for(String server: serverArray) {
            if(!pattern.matcher(server).matches()) {
                try {
                    InetAddress address = InetAddress.getByName(server);
                    log_.info("Server '%s' resolves to '%s'", server, address);
                } catch(UnknownHostException e) {
                    log_.error("Failed to resolve the given hostname '%s', this is a fatal error", server);
                    result = false;
                }
            }
        }
        return result;
    }

    static String exceptToString(Throwable e) {
        StringBuilder builder = new StringBuilder();
        builder.append(e.getMessage()).append("\n");
        for(StackTraceElement stack: e.getStackTrace())
            builder.append("   ").append(stack.toString()).append("\n");
        return builder.toString();
    }

    final Logger log_;
    final String voltdbServers_;
    final String localJarFile_;
    final String systemManifestFile_;
    final String machineConfigFile_;
    final String rasEventMetaDataFile_;
          Client client_;
    final String sql_;
    final long   connectTimeoutSeconds_;

    final static Map<String,DaiVoltState> conversionMap_ = new HashMap<>() {{
        put("schema-loaded", DaiVoltState.SCHEMA_LOADED);
        put("schema-loading", DaiVoltState.SCHEMA_LOADING);
        put("schema-error", DaiVoltState.SCHEMA_ERROR);
        put("populate-started", DaiVoltState.POPULATE_STARTED);
        put("populate-completed", DaiVoltState.READY);
        put("populate-error", DaiVoltState.POPULATED_ERROR);
    }};

    final static List<DaiVoltState> badStates_ = new ArrayList<>() {{
        add(DaiVoltState.CANNOT_CONNECT);
        add(DaiVoltState.SCHEMA_LOADING);
        add(DaiVoltState.SCHEMA_ERROR);
        add(DaiVoltState.POPULATE_STARTED);
        add(DaiVoltState.POPULATED_ERROR);
    }};

    /////////////////////////////////////////////////////////////////////
    // Some canned SQL statements related to DBStatus and Tier2_Config.
    final static String dbStatusTableAndProcedures = "CREATE TABLE DbStatus (\n" +
            "   Id                   Integer                  NOT NULL,\n" +
            "   Status               VarChar(32)              NOT NULL,\n" +
            "   Description          VarChar(4096)            NOT NULL,\n" +
            "   SchemaStartStamp     TIMESTAMP                NOT NULL,\n" +
            "   SchemeCompletedStamp TIMESTAMP,\n" +
            "   PopulateStartStamp   TIMESTAMP,\n" +
            "   PopulateFinishStamp  TIMESTAMP,\n" +
            ");\n" +
            "CREATE PROCEDURE GetDbStatus AS SELECT Status, Description FROM DbStatus;\n" +
            "CREATE PROCEDURE SetDbSchemaFailed AS UPDATE DbStatus SET Status='schema-error',Description=?," +
            "SchemeCompletedStamp=CURRENT_TIMESTAMP WHERE Id=0;\n" +
            "CREATE PROCEDURE SetDbPopulationStatus AS UPDATE DbStatus SET Status=?,Description=?," +
            "PopulateStartStamp=CURRENT_TIMESTAMP WHERE Id=0;\n";

    final static String selectStatus = "SELECT Status FROM DbStatus;";
    final static String schemaLoading =
            "INSERT INTO DbStatus (Id, Status, Description, SchemaStartStamp) VALUES (0, 'schema-loading', '', " +
            "CURRENT_TIMESTAMP);";

    final static String schemaLoaded =
            "UPDATE DbStatus SET Status='schema-loaded', Description='', SchemeCompletedStamp=CURRENT_TIMESTAMP " +
            "WHERE Id=0;";

    final static String populateStarting =
            "UPDATE DbStatus SET Status='populate-started', Description='', POPULATESTARTSTAMP=CURRENT_TIMESTAMP " +
            "WHERE Id=0;";

    final static String populateFinished =
            "UPDATE DbStatus SET Status='populate-completed', Description='', POPULATEFINISHSTAMP=CURRENT_TIMESTAMP " +
            "WHERE Id=0;";

    final static String populateError =
            "UPDATE DbStatus SET Status='populate-error', Description=?, POPULATEFINISHSTAMP=CURRENT_TIMESTAMP " +
            "WHERE Id=0;";

    final static String tier2ConfigFalse =
            "INSERT INTO Tier2_Config VALUES('tier2_valid', 'false', 'Indicates whether the state of this tier 2 " +
                    "database is valid to use for initializing tier 1');";
}
